{"version":3,"sources":["../../../src/server/app-render/collect-segment-data.tsx"],"sourcesContent":["import type {\n  CacheNodeSeedData,\n  FlightRouterState,\n  InitialRSCPayload,\n  Segment,\n} from './types'\nimport type { ManifestNode } from '../../build/webpack/plugins/flight-manifest-plugin'\n\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { createFromReadableStream } from 'react-server-dom-webpack/client.edge'\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport { prerender } from 'react-server-dom-webpack/static.edge'\n\nimport {\n  streamFromBuffer,\n  streamToBuffer,\n} from '../stream-utils/node-web-streams-helper'\nimport { UNDERSCORE_NOT_FOUND_ROUTE } from '../../api/constants'\nimport { waitAtLeastOneReactRenderTask } from '../../lib/scheduler'\nimport type { LoadingModuleData } from '../../shared/lib/app-router-context.shared-runtime'\n\n// Contains metadata about the route tree. The client must fetch this before\n// it can fetch any actual segment data.\nexport type RootTreePrefetch = {\n  buildId: string\n  tree: TreePrefetch\n  head: React.ReactNode | null\n  isHeadPartial: boolean\n  staleTime: number\n}\n\nexport type TreePrefetch = {\n  // Access token. Required to fetch the segment data. In the future this will\n  // not be provided during a prefetch if the parent segment did not include it\n  // in its prerender; the client will have to perform a dynamic navigation in\n  // order to get the access token.\n  token: string\n\n  // The path to use when requesting the data for this segment (analogous to a\n  // URL). Also used as a cache key, although the server may specify a different\n  // cache key when it responds (analagous to a Vary header), like to omit\n  // params if they aren't used to compute the response. (This part not\n  // yet implemented)\n  path: string\n\n  // Child segments.\n  slots: null | {\n    [parallelRouteKey: string]: TreePrefetch\n  }\n\n  // Extra fields that only exist so we can reconstruct a FlightRouterState on\n  // the client. We may be able to unify TreePrefetch and FlightRouterState\n  // after some refactoring, but in the meantime it would be wasteful to add a\n  // bunch of new prefetch-only fields to FlightRouterState. So think of\n  // TreePrefetch as a superset of FlightRouterState.\n  extra: [segment: Segment, isRootLayout: boolean]\n}\n\nexport type SegmentPrefetch = {\n  buildId: string\n  rsc: React.ReactNode | null\n  loading: LoadingModuleData | Promise<LoadingModuleData>\n  isPartial: boolean\n}\n\nexport async function collectSegmentData(\n  fullPageDataBuffer: Buffer,\n  staleTime: number,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any\n): Promise<Map<string, Buffer>> {\n  // Traverse the router tree and generate a prefetch response for each segment.\n\n  // A mutable map to collect the results as we traverse the route tree.\n  const resultMap = new Map<string, Buffer>()\n\n  // Before we start, warm up the module cache by decoding the page data once.\n  // Then we can assume that any remaining async tasks that occur the next time\n  // are due to hanging promises caused by dynamic data access. Note we only\n  // have to do this once per page, not per individual segment.\n  //\n  try {\n    await createFromReadableStream(streamFromBuffer(fullPageDataBuffer), {\n      serverConsumerManifest,\n    })\n    await waitAtLeastOneReactRenderTask()\n  } catch {}\n\n  // Create an abort controller that we'll use to stop the stream.\n  const abortController = new AbortController()\n  const onCompletedProcessingRouteTree = async () => {\n    // Since all we're doing is decoding and re-encoding a cached prerender, if\n    // serializing the stream takes longer than a microtask, it must because of\n    // hanging promises caused by dynamic data.\n    await waitAtLeastOneReactRenderTask()\n    abortController.abort()\n  }\n\n  // Generate a stream for the route tree prefetch. While we're walking the\n  // tree, we'll also spawn additional tasks to generate the segment prefetches.\n  // The promises for these tasks are pushed to a mutable array that we will\n  // await once the route tree is fully rendered.\n  const segmentTasks: Array<Promise<[string, Buffer]>> = []\n  const { prelude: treeStream } = await prerender(\n    // RootTreePrefetch is not a valid return type for a React component, but\n    // we need to use a component so that when we decode the original stream\n    // inside of it, the side effects are transferred to the new stream.\n    // @ts-expect-error\n    <PrefetchTreeData\n      fullPageDataBuffer={fullPageDataBuffer}\n      serverConsumerManifest={serverConsumerManifest}\n      clientModules={clientModules}\n      staleTime={staleTime}\n      segmentTasks={segmentTasks}\n      onCompletedProcessingRouteTree={onCompletedProcessingRouteTree}\n    />,\n    clientModules,\n    {\n      signal: abortController.signal,\n      onError() {\n        // Ignore any errors. These would have already been reported when\n        // we created the full page data.\n      },\n    }\n  )\n\n  // Write the route tree to a special `/_tree` segment.\n  const treeBuffer = await streamToBuffer(treeStream)\n  resultMap.set('/_tree', treeBuffer)\n\n  // Now that we've finished rendering the route tree, all the segment tasks\n  // should have been spawned. Await them in parallel and write the segment\n  // prefetches to the result map.\n  for (const [segmentPath, buffer] of await Promise.all(segmentTasks)) {\n    resultMap.set(segmentPath, buffer)\n  }\n\n  return resultMap\n}\n\nasync function PrefetchTreeData({\n  fullPageDataBuffer,\n  serverConsumerManifest,\n  clientModules,\n  staleTime,\n  segmentTasks,\n  onCompletedProcessingRouteTree,\n}: {\n  fullPageDataBuffer: Buffer\n  serverConsumerManifest: any\n  clientModules: ManifestNode\n  staleTime: number\n  segmentTasks: Array<Promise<[string, Buffer]>>\n  onCompletedProcessingRouteTree: () => void\n}): Promise<RootTreePrefetch | null> {\n  // We're currently rendering a Flight response for the route tree prefetch.\n  // Inside this component, decode the Flight stream for the whole page. This is\n  // a hack to transfer the side effects from the original Flight stream (e.g.\n  // Float preloads) onto the Flight stream for the tree prefetch.\n  // TODO: React needs a better way to do this. Needed for Server Actions, too.\n  const initialRSCPayload: InitialRSCPayload = await createFromReadableStream(\n    createUnclosingPrefetchStream(streamFromBuffer(fullPageDataBuffer)),\n    {\n      serverConsumerManifest,\n    }\n  )\n\n  const buildId = initialRSCPayload.b\n\n  // FlightDataPath is an unsound type, hence the additional checks.\n  const flightDataPaths = initialRSCPayload.f\n  if (flightDataPaths.length !== 1 && flightDataPaths[0].length !== 3) {\n    console.error(\n      'Internal Next.js error: InitialRSCPayload does not match the expected ' +\n        'shape for a prerendered page during segment prefetch generation.'\n    )\n    return null\n  }\n  const flightRouterState: FlightRouterState = flightDataPaths[0][0]\n  const seedData: CacheNodeSeedData = flightDataPaths[0][1]\n  const head: React.ReactNode | null = flightDataPaths[0][2]\n\n  // Compute the route metadata tree by traversing the FlightRouterState. As we\n  // walk the tree, we will also spawn a task to produce a prefetch response for\n  // each segment.\n  const tree = await collectSegmentDataImpl(\n    flightRouterState,\n    buildId,\n    seedData,\n    fullPageDataBuffer,\n    clientModules,\n    serverConsumerManifest,\n    '',\n    '',\n    segmentTasks\n  )\n\n  const isHeadPartial = await isPartialRSCData(head, clientModules)\n\n  // Notify the abort controller that we're done processing the route tree.\n  // Anything async that happens after this point must be due to hanging\n  // promises in the original stream.\n  onCompletedProcessingRouteTree()\n\n  // Render the route tree to a special `/_tree` segment.\n  const treePrefetch: RootTreePrefetch = {\n    buildId,\n    tree,\n    head,\n    isHeadPartial,\n    staleTime,\n  }\n  return treePrefetch\n}\n\nasync function collectSegmentDataImpl(\n  route: FlightRouterState,\n  buildId: string,\n  seedData: CacheNodeSeedData | null,\n  fullPageDataBuffer: Buffer,\n  clientModules: ManifestNode,\n  serverConsumerManifest: any,\n  segmentPathStr: string,\n  accessToken: string,\n  segmentTasks: Array<Promise<[string, Buffer]>>\n): Promise<TreePrefetch> {\n  // Metadata about the segment. Sent as part of the tree prefetch. Null if\n  // there are no children.\n  let slotMetadata: { [parallelRouteKey: string]: TreePrefetch } | null = null\n\n  const children = route[1]\n  const seedDataChildren = seedData !== null ? seedData[2] : null\n  for (const parallelRouteKey in children) {\n    const childRoute = children[parallelRouteKey]\n    const childSegment = childRoute[0]\n    const childSeedData =\n      seedDataChildren !== null ? seedDataChildren[parallelRouteKey] : null\n    const childSegmentPathStr =\n      segmentPathStr +\n      '/' +\n      encodeChildSegmentAsFilesystemSafePathname(parallelRouteKey, childSegment)\n\n    // Create an access token for each child slot.\n    const childAccessToken = await createSegmentAccessToken(\n      segmentPathStr,\n      parallelRouteKey\n    )\n    const childTree = await collectSegmentDataImpl(\n      childRoute,\n      buildId,\n      childSeedData,\n      fullPageDataBuffer,\n      clientModules,\n      serverConsumerManifest,\n      childSegmentPathStr,\n      childAccessToken,\n      segmentTasks\n    )\n    if (slotMetadata === null) {\n      slotMetadata = {}\n    }\n    slotMetadata[parallelRouteKey] = childTree\n  }\n\n  if (seedData !== null) {\n    // Spawn a task to write the segment data to a new Flight stream.\n    segmentTasks.push(\n      // Since we're already in the middle of a render, wait until after the\n      // current task to escape the current rendering context.\n      waitAtLeastOneReactRenderTask().then(() =>\n        renderSegmentPrefetch(\n          buildId,\n          seedData,\n          segmentPathStr,\n          accessToken,\n          clientModules\n        )\n      )\n    )\n  } else {\n    // This segment does not have any seed data. Skip generating a prefetch\n    // response for it. We'll still include it in the route tree, though.\n    // TODO: We should encode in the route tree whether a segment is missing\n    // so we don't attempt to fetch it for no reason. As of now this shouldn't\n    // ever happen in practice, though.\n  }\n\n  // Metadata about the segment. Sent to the client as part of the\n  // tree prefetch.\n  const segment = route[0]\n  const isRootLayout = route[4]\n  return {\n    path: segmentPathStr === '' ? '/' : segmentPathStr,\n    token: accessToken,\n    slots: slotMetadata,\n    extra: [segment, isRootLayout === true],\n  }\n}\n\nasync function renderSegmentPrefetch(\n  buildId: string,\n  seedData: CacheNodeSeedData,\n  segmentPathStr: string,\n  accessToken: string,\n  clientModules: ManifestNode\n): Promise<[string, Buffer]> {\n  // Render the segment data to a stream.\n  // In the future, this is where we can include additional metadata, like the\n  // stale time and cache tags.\n  const rsc = seedData[1]\n  const loading = seedData[3]\n  const segmentPrefetch: SegmentPrefetch = {\n    buildId,\n    rsc,\n    loading,\n    isPartial: await isPartialRSCData(rsc, clientModules),\n  }\n  // Since all we're doing is decoding and re-encoding a cached prerender, if\n  // it takes longer than a microtask, it must because of hanging promises\n  // caused by dynamic data. Abort the stream at the end of the current task.\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => abortController.abort())\n  const { prelude: segmentStream } = await prerender(\n    segmentPrefetch,\n    clientModules,\n    {\n      signal: abortController.signal,\n      onError() {\n        // Ignore any errors. These would have already been reported when\n        // we created the full page data.\n      },\n    }\n  )\n  const segmentBuffer = await streamToBuffer(segmentStream)\n  // Add the buffer to the result map.\n  if (segmentPathStr === '') {\n    return ['/', segmentBuffer]\n  } else {\n    // The access token is appended to the end of the segment name. To request\n    // a segment, the client sends a header like:\n    //\n    //   Next-Router-Segment-Prefetch: /path/to/segment.accesstoken\n    //\n    // The segment path is provided by the tree prefetch, and the access\n    // token is provided in the parent layout's data.\n    const fullPath = `${segmentPathStr}.${accessToken}`\n    return [fullPath, segmentBuffer]\n  }\n}\n\nasync function isPartialRSCData(\n  rsc: React.ReactNode,\n  clientModules: ManifestNode\n): Promise<boolean> {\n  // We can determine if a segment contains only partial data if it takes longer\n  // than a task to encode, because dynamic data is encoded as an infinite\n  // promise. We must do this in a separate Flight prerender from the one that\n  // actually generates the prefetch stream because we need to include\n  // `isPartial` in the stream itself.\n  let isPartial = false\n  const abortController = new AbortController()\n  waitAtLeastOneReactRenderTask().then(() => {\n    // If we haven't yet finished the outer task, then it must be because we\n    // accessed dynamic data.\n    isPartial = true\n    abortController.abort()\n  })\n  await prerender(rsc, clientModules, {\n    signal: abortController.signal,\n    onError() {},\n  })\n  return isPartial\n}\n\n// TODO: Consider updating or unifying this encoding logic for segments with\n// createRouterCacheKey on the client, perhaps by including it as part of\n// the FlightRouterState. Theoretically the client should never have to do its\n// own encoding of segment keys; it can pass back whatever the server gave it.\nfunction encodeChildSegmentAsFilesystemSafePathname(\n  parallelRouteKey: string,\n  segment: Segment\n): string {\n  // Encode a child segment and its corresponding parallel route key to a\n  // filesystem-safe pathname. The format is internal-only and can be somewhat\n  // arbitrary as long as there are no collisions, because these will be used\n  // as filenames during build and in the incremental cache. They will also\n  // be sent by the client to request the corresponding segment, but they\n  // do not need to be decodable. The server will merely look for a matching\n  // file in the cache.\n  //\n  // For ease of debugging, the format looks roughly similar to the App Router\n  // convention for defining routes in the source, but again the exact format is\n  // not important as long as it's consistent between the client and server and\n  // meets the above requirements.\n  //\n  // TODO: If the segment did not read from params, then we can omit the\n  // params from the cache key. Need to track this during the prerender somehow.\n  let safeSegmentValue\n  if (typeof segment === 'string') {\n    safeSegmentValue = encodeParamValue(segment)\n  } else {\n    // Parameterized segments.\n    const [paramName, paramValue, paramType] = segment\n    let paramPrefix\n    switch (paramType) {\n      case 'c':\n      case 'ci':\n        paramPrefix = `[...${paramName}]`\n        break\n      case 'oc':\n        paramPrefix = `[[...${paramName}]]`\n        break\n      case 'd':\n      case 'di':\n        paramPrefix = `[${paramName}]`\n        break\n      default:\n        throw new Error('Unknown dynamic param type')\n    }\n    safeSegmentValue = `${paramPrefix}-${encodeParamValue(paramValue)}`\n  }\n  let result\n  if (parallelRouteKey === 'children') {\n    // Omit the parallel route key for children, since this is the most\n    // common case. Saves some bytes.\n    result = `${safeSegmentValue}`\n  } else {\n    result = `@${parallelRouteKey}/${safeSegmentValue}`\n  }\n  return result\n}\n\n// Define a regex pattern to match the most common characters found in a route\n// param. It excludes anything that might not be cross-platform filesystem\n// compatible, like |. It does not need to be precise because the fallback is to\n// just base64url-encode the whole parameter, which is fine; we just don't do it\n// by default for compactness, and for easier debugging.\nconst simpleParamValueRegex = /^[a-zA-Z0-9\\-_@]+$/\n\nfunction encodeParamValue(segment: string): string {\n  if (segment === UNDERSCORE_NOT_FOUND_ROUTE) {\n    // TODO: FlightRouterState encodes Not Found routes as \"/_not-found\". But\n    // params typically don't include the leading slash. We should use a\n    // different encoding to avoid this special case.\n    return '_not-found'\n  }\n  if (simpleParamValueRegex.test(segment)) {\n    return segment\n  }\n  // If there are any unsafe characters, base64url-encode the entire segment.\n  // We also add a $ prefix so it doesn't collide with the simple case.\n  return '$' + Buffer.from(segment, 'utf-8').toString('base64url')\n}\n\nasync function createSegmentAccessToken(\n  parentSegmentPathStr: string,\n  parallelRouteKey: string\n): Promise<string> {\n  // Create an access token that the client passes when requesting a segment.\n  // The token is sent to the client as part of the parent layout's data.\n  //\n  // The token is hash of the parent segment path and the parallel route key. A\n  // subtle detail here is that it does *not* include the value of the segment\n  // itself — the token grants access to the parallel route slot, not the\n  // particular segment that is rendered there.\n  //\n  // TODO: Because this only affects prefetches, this doesn't need to be secure.\n  // It's just for obfuscation. But eventually we will use this technique when\n  // performing dynamic navigations, to support auth checks in a layout that\n  // conditionally renders its slots. At that point we'll need to add a salt.\n\n  // Encode the inputs as Uint8Array\n  const encoder = new TextEncoder()\n  const data = encoder.encode(parentSegmentPathStr + parallelRouteKey)\n\n  // Use the Web Crypto API to generate a SHA-256 hash.\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data)\n\n  // Convert the ArrayBuffer to a hex string\n  const hashArray = new Uint8Array(hashBuffer)\n  const hashHex = Array.from(hashArray)\n    .map((byte) => byte.toString(16).padStart(2, '0'))\n    .join('')\n\n  return hashHex\n}\n\nfunction createUnclosingPrefetchStream(\n  originalFlightStream: ReadableStream<Uint8Array>\n): ReadableStream<Uint8Array> {\n  // When PPR is enabled, prefetch streams may contain references that never\n  // resolve, because that's how we encode dynamic data access. In the decoded\n  // object returned by the Flight client, these are reified into hanging\n  // promises that suspend during render, which is effectively what we want.\n  // The UI resolves when it switches to the dynamic data stream\n  // (via useDeferredValue(dynamic, static)).\n  //\n  // However, the Flight implementation currently errors if the server closes\n  // the response before all the references are resolved. As a cheat to work\n  // around this, we wrap the original stream in a new stream that never closes,\n  // and therefore doesn't error.\n  const reader = originalFlightStream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (!done) {\n          // Pass to the target stream and keep consuming the Flight response\n          // from the server.\n          controller.enqueue(value)\n          continue\n        }\n        // The server stream has closed. Exit, but intentionally do not close\n        // the target stream.\n        return\n      }\n    },\n  })\n}\n"],"names":["createFromReadableStream","prerender","streamFromBuffer","streamToBuffer","UNDERSCORE_NOT_FOUND_ROUTE","waitAtLeastOneReactRenderTask","collectSegmentData","fullPageDataBuffer","staleTime","clientModules","serverConsumerManifest","resultMap","Map","abortController","AbortController","onCompletedProcessingRouteTree","abort","segmentTasks","prelude","treeStream","PrefetchTreeData","signal","onError","treeBuffer","set","segmentPath","buffer","Promise","all","initialRSCPayload","createUnclosingPrefetchStream","buildId","b","flightDataPaths","f","length","console","error","flightRouterState","seedData","head","tree","collectSegmentDataImpl","isHeadPartial","isPartialRSCData","treePrefetch","route","segmentPathStr","accessToken","slotMetadata","children","seedDataChildren","parallelRouteKey","childRoute","childSegment","childSeedData","childSegmentPathStr","encodeChildSegmentAsFilesystemSafePathname","childAccessToken","createSegmentAccessToken","childTree","push","then","renderSegmentPrefetch","segment","isRootLayout","path","token","slots","extra","rsc","loading","segmentPrefetch","isPartial","segmentStream","segmentBuffer","fullPath","safeSegmentValue","encodeParamValue","paramName","paramValue","paramType","paramPrefix","Error","result","simpleParamValueRegex","test","Buffer","from","toString","parentSegmentPathStr","encoder","TextEncoder","data","encode","hashBuffer","crypto","subtle","digest","hashArray","Uint8Array","hashHex","Array","map","byte","padStart","join","originalFlightStream","reader","getReader","ReadableStream","pull","controller","done","value","read","enqueue"],"mappings":"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"}