{"version":3,"sources":["../../../../src/server/lib/cache-handlers/default.ts"],"sourcesContent":["/*\n  This is the default \"use cache\" handler it defaults\n  to an in memory store\n*/\nimport { LRUCache } from '../lru-cache'\nimport type { CacheEntry, CacheHandler } from './types'\nimport {\n  isTagStale,\n  tagsManifest,\n} from '../incremental-cache/tags-manifest.external'\n\ntype PrivateCacheEntry = {\n  entry: CacheEntry\n\n  // For the default cache we store errored cache\n  // entries and allow them to be used up to 3 times\n  // after that we want to dispose it and try for fresh\n\n  // If an entry is errored we return no entry\n  // three times so that we retry hitting origin (MISS)\n  // and then if it still fails to set after the third we\n  // return the errored content and use expiration of\n  // Math.min(30, entry.expiration)\n  isErrored: boolean\n  errorRetryCount: number\n\n  // compute size on set since we need to read size\n  // of the ReadableStream for LRU evicting\n  size: number\n}\n\n// LRU cache default to max 50 MB but in future track\nconst memoryCache = new LRUCache<PrivateCacheEntry>(50_000_000)\nconst pendingSets = new Map<string, Promise<void>>()\n\nconst DefaultCacheHandler: CacheHandler = {\n  async get(cacheKey, softTags) {\n    await pendingSets.get(cacheKey)\n\n    const privateEntry = memoryCache.get(cacheKey)\n\n    if (!privateEntry) {\n      return undefined\n    }\n\n    const entry = privateEntry.entry\n    if (\n      performance.timeOrigin + performance.now() >\n      entry.timestamp + entry.revalidate * 1000\n    ) {\n      // In memory caches should expire after revalidate time because it is unlikely that\n      // a new entry will be able to be used before it is dropped from the cache.\n      return undefined\n    }\n\n    if (\n      isTagStale(entry.tags, entry.timestamp) ||\n      isTagStale(softTags, entry.timestamp)\n    ) {\n      return undefined\n    }\n    const [returnStream, newSaved] = entry.value.tee()\n    entry.value = newSaved\n\n    return {\n      ...entry,\n      value: returnStream,\n    }\n  },\n\n  async set(cacheKey, pendingEntry) {\n    let resolvePending: () => void = () => {}\n    const pendingPromise = new Promise<void>((resolve) => {\n      resolvePending = resolve\n    })\n    pendingSets.set(cacheKey, pendingPromise)\n\n    const entry = await pendingEntry\n\n    let size = 0\n\n    try {\n      const [value, clonedValue] = entry.value.tee()\n      entry.value = value\n      const reader = clonedValue.getReader()\n\n      for (let chunk; !(chunk = await reader.read()).done; ) {\n        size += Buffer.from(chunk.value).byteLength\n      }\n\n      memoryCache.set(cacheKey, {\n        entry,\n        isErrored: false,\n        errorRetryCount: 0,\n        size,\n      })\n    } catch (err) {\n      console.error(`Error while saving cache key: ${cacheKey}`, err)\n      // TODO: store partial buffer with error after we retry 3 times\n    } finally {\n      resolvePending()\n      pendingSets.delete(cacheKey)\n    }\n  },\n\n  async unstable_expireTags(...tags) {\n    for (const tag of tags) {\n      if (!tagsManifest.items[tag]) {\n        tagsManifest.items[tag] = {}\n      }\n      // TODO: use performance.now and update file-system-cache?\n      tagsManifest.items[tag].revalidatedAt = Date.now()\n    }\n  },\n\n  async receiveExpiredTags(...tags): Promise<void> {\n    return this.unstable_expireTags(...tags)\n  },\n}\n\nexport default DefaultCacheHandler\n"],"names":["LRUCache","isTagStale","tagsManifest","memoryCache","pendingSets","Map","DefaultCacheHandler","get","cacheKey","softTags","privateEntry","undefined","entry","performance","timeOrigin","now","timestamp","revalidate","tags","returnStream","newSaved","value","tee","set","pendingEntry","resolvePending","pendingPromise","Promise","resolve","size","clonedValue","reader","getReader","chunk","read","done","Buffer","from","byteLength","isErrored","errorRetryCount","err","console","error","delete","unstable_expireTags","tag","items","revalidatedAt","Date","receiveExpiredTags"],"mappings":"AAAA;;;AAGA,GACA,SAASA,QAAQ,QAAQ,eAAc;AAEvC,SACEC,UAAU,EACVC,YAAY,QACP,8CAA6C;AAsBpD,qDAAqD;AACrD,MAAMC,cAAc,IAAIH,SAA4B;AACpD,MAAMI,cAAc,IAAIC;AAExB,MAAMC,sBAAoC;IACxC,MAAMC,KAAIC,QAAQ,EAAEC,QAAQ;QAC1B,MAAML,YAAYG,GAAG,CAACC;QAEtB,MAAME,eAAeP,YAAYI,GAAG,CAACC;QAErC,IAAI,CAACE,cAAc;YACjB,OAAOC;QACT;QAEA,MAAMC,QAAQF,aAAaE,KAAK;QAChC,IACEC,YAAYC,UAAU,GAAGD,YAAYE,GAAG,KACxCH,MAAMI,SAAS,GAAGJ,MAAMK,UAAU,GAAG,MACrC;YACA,mFAAmF;YACnF,2EAA2E;YAC3E,OAAON;QACT;QAEA,IACEV,WAAWW,MAAMM,IAAI,EAAEN,MAAMI,SAAS,KACtCf,WAAWQ,UAAUG,MAAMI,SAAS,GACpC;YACA,OAAOL;QACT;QACA,MAAM,CAACQ,cAAcC,SAAS,GAAGR,MAAMS,KAAK,CAACC,GAAG;QAChDV,MAAMS,KAAK,GAAGD;QAEd,OAAO;YACL,GAAGR,KAAK;YACRS,OAAOF;QACT;IACF;IAEA,MAAMI,KAAIf,QAAQ,EAAEgB,YAAY;QAC9B,IAAIC,iBAA6B,KAAO;QACxC,MAAMC,iBAAiB,IAAIC,QAAc,CAACC;YACxCH,iBAAiBG;QACnB;QACAxB,YAAYmB,GAAG,CAACf,UAAUkB;QAE1B,MAAMd,QAAQ,MAAMY;QAEpB,IAAIK,OAAO;QAEX,IAAI;YACF,MAAM,CAACR,OAAOS,YAAY,GAAGlB,MAAMS,KAAK,CAACC,GAAG;YAC5CV,MAAMS,KAAK,GAAGA;YACd,MAAMU,SAASD,YAAYE,SAAS;YAEpC,IAAK,IAAIC,OAAO,CAAC,AAACA,CAAAA,QAAQ,MAAMF,OAAOG,IAAI,EAAC,EAAGC,IAAI,EAAI;gBACrDN,QAAQO,OAAOC,IAAI,CAACJ,MAAMZ,KAAK,EAAEiB,UAAU;YAC7C;YAEAnC,YAAYoB,GAAG,CAACf,UAAU;gBACxBI;gBACA2B,WAAW;gBACXC,iBAAiB;gBACjBX;YACF;QACF,EAAE,OAAOY,KAAK;YACZC,QAAQC,KAAK,CAAC,CAAC,8BAA8B,EAAEnC,UAAU,EAAEiC;QAC3D,+DAA+D;QACjE,SAAU;YACRhB;YACArB,YAAYwC,MAAM,CAACpC;QACrB;IACF;IAEA,MAAMqC,qBAAoB,GAAG3B,IAAI;QAC/B,KAAK,MAAM4B,OAAO5B,KAAM;YACtB,IAAI,CAAChB,aAAa6C,KAAK,CAACD,IAAI,EAAE;gBAC5B5C,aAAa6C,KAAK,CAACD,IAAI,GAAG,CAAC;YAC7B;YACA,0DAA0D;YAC1D5C,aAAa6C,KAAK,CAACD,IAAI,CAACE,aAAa,GAAGC,KAAKlC,GAAG;QAClD;IACF;IAEA,MAAMmC,oBAAmB,GAAGhC,IAAI;QAC9B,OAAO,IAAI,CAAC2B,mBAAmB,IAAI3B;IACrC;AACF;AAEA,eAAeZ,oBAAmB"}