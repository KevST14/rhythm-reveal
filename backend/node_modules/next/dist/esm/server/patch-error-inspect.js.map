{"version":3,"sources":["../../src/server/patch-error-inspect.ts"],"sourcesContent":["import {\n  findSourceMap as nativeFindSourceMap,\n  type SourceMapPayload,\n} from 'module'\nimport * as path from 'path'\nimport * as url from 'url'\nimport type * as util from 'util'\nimport { SourceMapConsumer as SyncSourceMapConsumer } from 'next/dist/compiled/source-map'\nimport type { StackFrame } from 'next/dist/compiled/stacktrace-parser'\nimport { parseStack } from '../client/components/react-dev-overlay/server/middleware-webpack'\nimport { getOriginalCodeFrame } from '../client/components/react-dev-overlay/server/shared'\nimport { workUnitAsyncStorage } from './app-render/work-unit-async-storage.external'\nimport { dim } from '../lib/picocolors'\n\ntype FindSourceMapPayload = (\n  sourceURL: string\n) => ModernSourceMapPayload | undefined\n// Find a source map using the bundler's API.\n// This is only a fallback for when Node.js fails to due to bugs e.g. https://github.com/nodejs/node/issues/52102\n// TODO: Remove once all supported Node.js versions are fixed.\n// TODO(veil): Set from Webpack as well\nlet bundlerFindSourceMapPayload: FindSourceMapPayload = () => undefined\n\nexport function setBundlerFindSourceMapImplementation(\n  findSourceMapImplementation: FindSourceMapPayload\n): void {\n  bundlerFindSourceMapPayload = findSourceMapImplementation\n}\n\n/**\n * https://tc39.es/source-map/#index-map\n */\ninterface IndexSourceMapSection {\n  offset: {\n    line: number\n    column: number\n  }\n  map: ModernRawSourceMap\n}\n\n// TODO(veil): Upstream types\ninterface IndexSourceMap {\n  version: number\n  file: string\n  sections: IndexSourceMapSection[]\n}\n\ninterface ModernRawSourceMap extends SourceMapPayload {\n  ignoreList?: number[]\n}\n\nexport type ModernSourceMapPayload = ModernRawSourceMap | IndexSourceMap\n\ninterface IgnoreableStackFrame extends StackFrame {\n  ignored: boolean\n}\n\ntype SourceMapCache = Map<\n  string,\n  { map: SyncSourceMapConsumer; payload: ModernSourceMapPayload }\n>\n\nfunction frameToString(frame: StackFrame): string {\n  let sourceLocation = frame.lineNumber !== null ? `:${frame.lineNumber}` : ''\n  if (frame.column !== null && sourceLocation !== '') {\n    sourceLocation += `:${frame.column}`\n  }\n\n  let fileLocation: string | null\n  if (\n    frame.file !== null &&\n    frame.file.startsWith('file://') &&\n    URL.canParse(frame.file)\n  ) {\n    // If not relative to CWD, the path is ambiguous to IDEs and clicking will prompt to select the file first.\n    // In a multi-app repo, this leads to potentially larger file names but will make clicking snappy.\n    // There's no tradeoff for the cases where `dir` in `next dev [dir]` is omitted\n    // since relative to cwd is both the shortest and snappiest.\n    fileLocation = path.relative(process.cwd(), url.fileURLToPath(frame.file))\n  } else if (frame.file !== null && frame.file.startsWith('/')) {\n    fileLocation = path.relative(process.cwd(), frame.file)\n  } else {\n    fileLocation = frame.file\n  }\n\n  return frame.methodName\n    ? `    at ${frame.methodName} (${fileLocation}${sourceLocation})`\n    : `    at ${fileLocation}${sourceLocation}`\n}\n\nfunction computeErrorName(error: Error): string {\n  // TODO: Node.js seems to use a different algorithm\n  // class ReadonlyRequestCookiesError extends Error {}` would read `ReadonlyRequestCookiesError: [...]`\n  // in the stack i.e. seems like under certain conditions it favors the constructor name.\n  return error.name || 'Error'\n}\n\nfunction prepareUnsourcemappedStackTrace(\n  error: Error,\n  structuredStackTrace: any[]\n): string {\n  const name = computeErrorName(error)\n  const message = error.message || ''\n  let stack = name + ': ' + message\n  for (let i = 0; i < structuredStackTrace.length; i++) {\n    stack += '\\n    at ' + structuredStackTrace[i].toString()\n  }\n  return stack\n}\n\nfunction shouldIgnoreListGeneratedFrame(file: string): boolean {\n  return file.startsWith('node:') || file.includes('node_modules')\n}\n\nfunction shouldIgnoreListOriginalFrame(file: string): boolean {\n  return file.includes('node_modules')\n}\n\n/**\n * Finds the sourcemap payload applicable to a given frame.\n * Equal to the input unless an Index Source Map is used.\n */\nfunction findApplicableSourceMapPayload(\n  frame: StackFrame,\n  payload: ModernSourceMapPayload\n): ModernRawSourceMap | undefined {\n  if ('sections' in payload) {\n    const frameLine = frame.lineNumber ?? 0\n    const frameColumn = frame.column ?? 0\n    // Sections must not overlap and must be sorted: https://tc39.es/source-map/#section-object\n    // Therefore the last section that has an offset less than or equal to the frame is the applicable one.\n    // TODO(veil): Binary search\n    let section: IndexSourceMapSection | undefined = payload.sections[0]\n    for (\n      let i = 0;\n      i < payload.sections.length &&\n      payload.sections[i].offset.line <= frameLine &&\n      payload.sections[i].offset.column <= frameColumn;\n      i++\n    ) {\n      section = payload.sections[i]\n    }\n\n    return section === undefined ? undefined : section.map\n  } else {\n    return payload\n  }\n}\n\ninterface SourcemappableStackFrame extends StackFrame {\n  file: NonNullable<StackFrame['file']>\n}\n\n/**\n * @param frame\n * @param sourceMapCache\n * @returns The original frame if not sourcemapped.\n */\nfunction getSourcemappedFrameIfPossible(\n  frame: SourcemappableStackFrame,\n  sourceMapCache: SourceMapCache\n): {\n  stack: IgnoreableStackFrame\n  // DEV only\n  code: string | null\n} {\n  const sourceMapCacheEntry = sourceMapCache.get(frame.file)\n  let sourceMapConsumer: SyncSourceMapConsumer\n  let sourceMapPayload: ModernSourceMapPayload\n  if (sourceMapCacheEntry === undefined) {\n    let sourceURL = frame.file\n    // e.g. \"/APP/.next/server/chunks/ssr/[root of the server]__2934a0._.js\"\n    // will be keyed by Node.js as \"file:///APP/.next/server/chunks/ssr/[root%20of%20the%20server]__2934a0._.js\".\n    // This is likely caused by `callsite.toString()` in `Error.prepareStackTrace converting file URLs to paths.\n    if (sourceURL.startsWith('/')) {\n      sourceURL = url.pathToFileURL(frame.file).toString()\n    }\n    const maybeSourceMapPayload =\n      nativeFindSourceMap(sourceURL)?.payload ??\n      bundlerFindSourceMapPayload(sourceURL)\n    if (maybeSourceMapPayload === undefined) {\n      return {\n        stack: {\n          arguments: frame.arguments,\n          column: frame.column,\n          file: frame.file,\n          lineNumber: frame.lineNumber,\n          methodName: frame.methodName,\n          ignored: shouldIgnoreListGeneratedFrame(frame.file),\n        },\n        code: null,\n      }\n    }\n    sourceMapPayload = maybeSourceMapPayload\n    sourceMapConsumer = new SyncSourceMapConsumer(\n      // @ts-expect-error -- Module.SourceMap['version'] is number but SyncSourceMapConsumer wants a string\n      sourceMapPayload\n    )\n    sourceMapCache.set(frame.file, {\n      map: sourceMapConsumer,\n      payload: sourceMapPayload,\n    })\n  } else {\n    sourceMapConsumer = sourceMapCacheEntry.map\n    sourceMapPayload = sourceMapCacheEntry.payload\n  }\n\n  const sourcePosition = sourceMapConsumer.originalPositionFor({\n    column: frame.column ?? 0,\n    line: frame.lineNumber ?? 1,\n  })\n\n  if (sourcePosition.source === null) {\n    return {\n      stack: {\n        arguments: frame.arguments,\n        column: frame.column,\n        file: frame.file,\n        lineNumber: frame.lineNumber,\n        methodName: frame.methodName,\n        ignored: shouldIgnoreListGeneratedFrame(frame.file),\n      },\n      code: null,\n    }\n  }\n\n  const sourceContent: string | null =\n    sourceMapConsumer.sourceContentFor(\n      sourcePosition.source,\n      /* returnNullOnMissing */ true\n    ) ?? null\n\n  const applicableSourceMap = findApplicableSourceMapPayload(\n    frame,\n    sourceMapPayload\n  )\n  // TODO(veil): Upstream a method to sourcemap consumer that immediately says if a frame is ignored or not.\n  let ignored = false\n  if (applicableSourceMap === undefined) {\n    console.error('No applicable source map found in sections for frame', frame)\n  } else if (shouldIgnoreListOriginalFrame(sourcePosition.source)) {\n    // Externals may be libraries that don't ship ignoreLists.\n    // This is really taking control away from libraries.\n    // They should still ship `ignoreList` so that attached debuggers ignore-list their frames.\n    // TODO: Maybe only ignore library sourcemaps if `ignoreList` is absent?\n    // Though keep in mind that Turbopack omits empty `ignoreList`.\n    // So if we establish this convention, we should communicate it to the ecosystem.\n    ignored = true\n  } else {\n    // TODO: O(n^2). Consider moving `ignoreList` into a Set\n    const sourceIndex = applicableSourceMap.sources.indexOf(\n      sourcePosition.source\n    )\n    ignored = applicableSourceMap.ignoreList?.includes(sourceIndex) ?? false\n  }\n\n  const originalFrame: IgnoreableStackFrame = {\n    methodName:\n      sourcePosition.name ||\n      // default is not a valid identifier in JS so webpack uses a custom variable when it's an unnamed default export\n      // Resolve it back to `default` for the method name if the source position didn't have the method.\n      frame.methodName\n        ?.replace('__WEBPACK_DEFAULT_EXPORT__', 'default')\n        ?.replace('__webpack_exports__.', ''),\n    column: sourcePosition.column,\n    file: sourcePosition.source,\n    lineNumber: sourcePosition.line,\n    // TODO: c&p from async createOriginalStackFrame but why not frame.arguments?\n    arguments: [],\n    ignored,\n  }\n\n  const codeFrame =\n    process.env.NODE_ENV !== 'production'\n      ? getOriginalCodeFrame(originalFrame, sourceContent)\n      : null\n\n  return {\n    stack: originalFrame,\n    code: codeFrame,\n  }\n}\n\nfunction parseAndSourceMap(error: Error): string {\n  // TODO(veil): Expose as CLI arg or config option. Useful for local debugging.\n  const showIgnoreListed = false\n  // We overwrote Error.prepareStackTrace earlier so error.stack is not sourcemapped.\n  let unparsedStack = String(error.stack)\n  // We could just read it from `error.stack`.\n  // This works around cases where a 3rd party `Error.prepareStackTrace` implementation\n  // doesn't implement the name computation correctly.\n  const errorName = computeErrorName(error)\n\n  let idx = unparsedStack.indexOf('react-stack-bottom-frame')\n  if (idx !== -1) {\n    idx = unparsedStack.lastIndexOf('\\n', idx)\n  }\n  if (idx !== -1 && !showIgnoreListed) {\n    // Cut off everything after the bottom frame since it'll be React internals.\n    unparsedStack = unparsedStack.slice(0, idx)\n  }\n\n  const unsourcemappedStack = parseStack(unparsedStack)\n  const sourceMapCache: SourceMapCache = new Map()\n\n  let sourceMappedStack = ''\n  let sourceFrameDEV: null | string = null\n  for (const frame of unsourcemappedStack) {\n    if (frame.file === null) {\n      sourceMappedStack += '\\n' + frameToString(frame)\n    } else {\n      const sourcemappedFrame = getSourcemappedFrameIfPossible(\n        // We narrowed this earlier by bailing if `frame.file` is null.\n        frame as SourcemappableStackFrame,\n        sourceMapCache\n      )\n\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        sourcemappedFrame.code !== null &&\n        sourceFrameDEV === null &&\n        // TODO: Is this the right choice?\n        !sourcemappedFrame.stack.ignored\n      ) {\n        sourceFrameDEV = sourcemappedFrame.code\n      }\n      if (!sourcemappedFrame.stack.ignored) {\n        // TODO: Consider what happens if every frame is ignore listed.\n        sourceMappedStack += '\\n' + frameToString(sourcemappedFrame.stack)\n      } else if (showIgnoreListed) {\n        sourceMappedStack += '\\n' + dim(frameToString(sourcemappedFrame.stack))\n      }\n    }\n  }\n\n  return (\n    errorName +\n    ': ' +\n    error.message +\n    sourceMappedStack +\n    (sourceFrameDEV !== null ? '\\n' + sourceFrameDEV : '')\n  )\n}\n\nfunction sourceMapError(this: void, error: Error): Error {\n  // Create a new Error object with the source mapping applied and then use native\n  // Node.js formatting on the result.\n  const newError =\n    error.cause !== undefined\n      ? // Setting an undefined `cause` would print `[cause]: undefined`\n        new Error(error.message, { cause: error.cause })\n      : new Error(error.message)\n\n  // TODO: Ensure `class MyError extends Error {}` prints `MyError` as the name\n  newError.stack = parseAndSourceMap(error)\n\n  for (const key in error) {\n    if (!Object.prototype.hasOwnProperty.call(newError, key)) {\n      // @ts-expect-error -- We're copying all enumerable properties.\n      // So they definitely exist on `this` and obviously have no type on `newError` (yet)\n      newError[key] = error[key]\n    }\n  }\n\n  return newError\n}\n\nexport function patchErrorInspectNodeJS(\n  errorConstructor: ErrorConstructor\n): void {\n  const inspectSymbol = Symbol.for('nodejs.util.inspect.custom')\n\n  errorConstructor.prepareStackTrace = prepareUnsourcemappedStackTrace\n\n  // @ts-expect-error -- TODO upstream types\n  // eslint-disable-next-line no-extend-native -- We're not extending but overriding.\n  errorConstructor.prototype[inspectSymbol] = function (\n    depth: number,\n    inspectOptions: util.InspectOptions,\n    inspect: typeof util.inspect\n  ): string {\n    // avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.\n    return workUnitAsyncStorage.exit(() => {\n      const newError = sourceMapError(this)\n\n      const originalCustomInspect = (newError as any)[inspectSymbol]\n      // Prevent infinite recursion.\n      // { customInspect: false } would result in `error.cause` not using our inspect.\n      Object.defineProperty(newError, inspectSymbol, {\n        value: undefined,\n        enumerable: false,\n        writable: true,\n      })\n      try {\n        return inspect(newError, {\n          ...inspectOptions,\n          depth:\n            (inspectOptions.depth ??\n              // Default in Node.js\n              2) - depth,\n        })\n      } finally {\n        ;(newError as any)[inspectSymbol] = originalCustomInspect\n      }\n    })\n  }\n}\n\nexport function patchErrorInspectEdgeLite(\n  errorConstructor: ErrorConstructor\n): void {\n  const inspectSymbol = Symbol.for('edge-runtime.inspect.custom')\n\n  errorConstructor.prepareStackTrace = prepareUnsourcemappedStackTrace\n\n  // @ts-expect-error -- TODO upstream types\n  // eslint-disable-next-line no-extend-native -- We're not extending but overriding.\n  errorConstructor.prototype[inspectSymbol] = function ({\n    format,\n  }: {\n    format: (...args: unknown[]) => string\n  }): string {\n    // avoid false-positive dynamic i/o warnings e.g. due to usage of `Math.random` in `source-map`.\n    return workUnitAsyncStorage.exit(() => {\n      const newError = sourceMapError(this)\n\n      const originalCustomInspect = (newError as any)[inspectSymbol]\n      // Prevent infinite recursion.\n      Object.defineProperty(newError, inspectSymbol, {\n        value: undefined,\n        enumerable: false,\n        writable: true,\n      })\n      try {\n        return format(newError)\n      } finally {\n        ;(newError as any)[inspectSymbol] = originalCustomInspect\n      }\n    })\n  }\n}\n"],"names":["findSourceMap","nativeFindSourceMap","path","url","SourceMapConsumer","SyncSourceMapConsumer","parseStack","getOriginalCodeFrame","workUnitAsyncStorage","dim","bundlerFindSourceMapPayload","undefined","setBundlerFindSourceMapImplementation","findSourceMapImplementation","frameToString","frame","sourceLocation","lineNumber","column","fileLocation","file","startsWith","URL","canParse","relative","process","cwd","fileURLToPath","methodName","computeErrorName","error","name","prepareUnsourcemappedStackTrace","structuredStackTrace","message","stack","i","length","toString","shouldIgnoreListGeneratedFrame","includes","shouldIgnoreListOriginalFrame","findApplicableSourceMapPayload","payload","frameLine","frameColumn","section","sections","offset","line","map","getSourcemappedFrameIfPossible","sourceMapCache","sourceMapCacheEntry","get","sourceMapConsumer","sourceMapPayload","sourceURL","pathToFileURL","maybeSourceMapPayload","arguments","ignored","code","set","sourcePosition","originalPositionFor","source","sourceContent","sourceContentFor","applicableSourceMap","console","sourceIndex","sources","indexOf","ignoreList","originalFrame","replace","codeFrame","env","NODE_ENV","parseAndSourceMap","showIgnoreListed","unparsedStack","String","errorName","idx","lastIndexOf","slice","unsourcemappedStack","Map","sourceMappedStack","sourceFrameDEV","sourcemappedFrame","sourceMapError","newError","cause","Error","key","Object","prototype","hasOwnProperty","call","patchErrorInspectNodeJS","errorConstructor","inspectSymbol","Symbol","for","prepareStackTrace","depth","inspectOptions","inspect","exit","originalCustomInspect","defineProperty","value","enumerable","writable","patchErrorInspectEdgeLite","format"],"mappings":"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"}