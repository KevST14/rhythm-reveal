{"version":3,"sources":["../../../../src/server/lib/cache-handlers/default.ts"],"sourcesContent":["/*\n  This is the default \"use cache\" handler it defaults\n  to an in memory store\n*/\nimport { LRUCache } from '../lru-cache'\nimport type { CacheEntry, CacheHandler } from './types'\nimport {\n  isTagStale,\n  tagsManifest,\n} from '../incremental-cache/tags-manifest.external'\n\ntype PrivateCacheEntry = {\n  entry: CacheEntry\n\n  // For the default cache we store errored cache\n  // entries and allow them to be used up to 3 times\n  // after that we want to dispose it and try for fresh\n\n  // If an entry is errored we return no entry\n  // three times so that we retry hitting origin (MISS)\n  // and then if it still fails to set after the third we\n  // return the errored content and use expiration of\n  // Math.min(30, entry.expiration)\n  isErrored: boolean\n  errorRetryCount: number\n\n  // compute size on set since we need to read size\n  // of the ReadableStream for LRU evicting\n  size: number\n}\n\n// LRU cache default to max 50 MB but in future track\nconst memoryCache = new LRUCache<PrivateCacheEntry>(50_000_000)\nconst pendingSets = new Map<string, Promise<void>>()\n\nconst DefaultCacheHandler: CacheHandler = {\n  async get(cacheKey, softTags) {\n    await pendingSets.get(cacheKey)\n\n    const privateEntry = memoryCache.get(cacheKey)\n\n    if (!privateEntry) {\n      return undefined\n    }\n\n    const entry = privateEntry.entry\n    if (\n      performance.timeOrigin + performance.now() >\n      entry.timestamp + entry.revalidate * 1000\n    ) {\n      // In memory caches should expire after revalidate time because it is unlikely that\n      // a new entry will be able to be used before it is dropped from the cache.\n      return undefined\n    }\n\n    if (\n      isTagStale(entry.tags, entry.timestamp) ||\n      isTagStale(softTags, entry.timestamp)\n    ) {\n      return undefined\n    }\n    const [returnStream, newSaved] = entry.value.tee()\n    entry.value = newSaved\n\n    return {\n      ...entry,\n      value: returnStream,\n    }\n  },\n\n  async set(cacheKey, pendingEntry) {\n    let resolvePending: () => void = () => {}\n    const pendingPromise = new Promise<void>((resolve) => {\n      resolvePending = resolve\n    })\n    pendingSets.set(cacheKey, pendingPromise)\n\n    const entry = await pendingEntry\n\n    let size = 0\n\n    try {\n      const [value, clonedValue] = entry.value.tee()\n      entry.value = value\n      const reader = clonedValue.getReader()\n\n      for (let chunk; !(chunk = await reader.read()).done; ) {\n        size += Buffer.from(chunk.value).byteLength\n      }\n\n      memoryCache.set(cacheKey, {\n        entry,\n        isErrored: false,\n        errorRetryCount: 0,\n        size,\n      })\n    } catch (err) {\n      console.error(`Error while saving cache key: ${cacheKey}`, err)\n      // TODO: store partial buffer with error after we retry 3 times\n    } finally {\n      resolvePending()\n      pendingSets.delete(cacheKey)\n    }\n  },\n\n  async unstable_expireTags(...tags) {\n    for (const tag of tags) {\n      if (!tagsManifest.items[tag]) {\n        tagsManifest.items[tag] = {}\n      }\n      // TODO: use performance.now and update file-system-cache?\n      tagsManifest.items[tag].revalidatedAt = Date.now()\n    }\n  },\n\n  async receiveExpiredTags(...tags): Promise<void> {\n    return this.unstable_expireTags(...tags)\n  },\n}\n\nexport default DefaultCacheHandler\n"],"names":["memoryCache","LRUCache","pendingSets","Map","DefaultCacheHandler","get","cacheKey","softTags","privateEntry","undefined","entry","performance","timeOrigin","now","timestamp","revalidate","isTagStale","tags","returnStream","newSaved","value","tee","set","pendingEntry","resolvePending","pendingPromise","Promise","resolve","size","clonedValue","reader","getReader","chunk","read","done","Buffer","from","byteLength","isErrored","errorRetryCount","err","console","error","delete","unstable_expireTags","tag","tagsManifest","items","revalidatedAt","Date","receiveExpiredTags"],"mappings":"AAAA;;;AAGA;;;;+BAqHA;;;eAAA;;;0BApHyB;sCAKlB;AAsBP,qDAAqD;AACrD,MAAMA,cAAc,IAAIC,kBAAQ,CAAoB;AACpD,MAAMC,cAAc,IAAIC;AAExB,MAAMC,sBAAoC;IACxC,MAAMC,KAAIC,QAAQ,EAAEC,QAAQ;QAC1B,MAAML,YAAYG,GAAG,CAACC;QAEtB,MAAME,eAAeR,YAAYK,GAAG,CAACC;QAErC,IAAI,CAACE,cAAc;YACjB,OAAOC;QACT;QAEA,MAAMC,QAAQF,aAAaE,KAAK;QAChC,IACEC,YAAYC,UAAU,GAAGD,YAAYE,GAAG,KACxCH,MAAMI,SAAS,GAAGJ,MAAMK,UAAU,GAAG,MACrC;YACA,mFAAmF;YACnF,2EAA2E;YAC3E,OAAON;QACT;QAEA,IACEO,IAAAA,gCAAU,EAACN,MAAMO,IAAI,EAAEP,MAAMI,SAAS,KACtCE,IAAAA,gCAAU,EAACT,UAAUG,MAAMI,SAAS,GACpC;YACA,OAAOL;QACT;QACA,MAAM,CAACS,cAAcC,SAAS,GAAGT,MAAMU,KAAK,CAACC,GAAG;QAChDX,MAAMU,KAAK,GAAGD;QAEd,OAAO;YACL,GAAGT,KAAK;YACRU,OAAOF;QACT;IACF;IAEA,MAAMI,KAAIhB,QAAQ,EAAEiB,YAAY;QAC9B,IAAIC,iBAA6B,KAAO;QACxC,MAAMC,iBAAiB,IAAIC,QAAc,CAACC;YACxCH,iBAAiBG;QACnB;QACAzB,YAAYoB,GAAG,CAAChB,UAAUmB;QAE1B,MAAMf,QAAQ,MAAMa;QAEpB,IAAIK,OAAO;QAEX,IAAI;YACF,MAAM,CAACR,OAAOS,YAAY,GAAGnB,MAAMU,KAAK,CAACC,GAAG;YAC5CX,MAAMU,KAAK,GAAGA;YACd,MAAMU,SAASD,YAAYE,SAAS;YAEpC,IAAK,IAAIC,OAAO,CAAC,AAACA,CAAAA,QAAQ,MAAMF,OAAOG,IAAI,EAAC,EAAGC,IAAI,EAAI;gBACrDN,QAAQO,OAAOC,IAAI,CAACJ,MAAMZ,KAAK,EAAEiB,UAAU;YAC7C;YAEArC,YAAYsB,GAAG,CAAChB,UAAU;gBACxBI;gBACA4B,WAAW;gBACXC,iBAAiB;gBACjBX;YACF;QACF,EAAE,OAAOY,KAAK;YACZC,QAAQC,KAAK,CAAC,CAAC,8BAA8B,EAAEpC,UAAU,EAAEkC;QAC3D,+DAA+D;QACjE,SAAU;YACRhB;YACAtB,YAAYyC,MAAM,CAACrC;QACrB;IACF;IAEA,MAAMsC,qBAAoB,GAAG3B,IAAI;QAC/B,KAAK,MAAM4B,OAAO5B,KAAM;YACtB,IAAI,CAAC6B,kCAAY,CAACC,KAAK,CAACF,IAAI,EAAE;gBAC5BC,kCAAY,CAACC,KAAK,CAACF,IAAI,GAAG,CAAC;YAC7B;YACA,0DAA0D;YAC1DC,kCAAY,CAACC,KAAK,CAACF,IAAI,CAACG,aAAa,GAAGC,KAAKpC,GAAG;QAClD;IACF;IAEA,MAAMqC,oBAAmB,GAAGjC,IAAI;QAC9B,OAAO,IAAI,CAAC2B,mBAAmB,IAAI3B;IACrC;AACF;MAEA,WAAeb"}